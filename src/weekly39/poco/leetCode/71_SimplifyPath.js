// https://leetcode.com/problems/simplify-path/?envType=study-plan-v2&envId=top-interview-150
/**
 * @param {string} path
 * @return {string}
 */
var simplifyPath = function (path) {
  // 경로를 담을 배열
  const stack = [];

  // 경로를 '/'로 나누어 배열에 담는다.
  path.split('/').forEach((el) => {
    // 경로가 '..'일 때, 배열의 마지막 요소를 제거한다.
    // 어차피 상위 디렉토리로 이동하는 것이기 때문에 배열의 마지막 요소를 제거한다.
    if (el === '..') {
      stack.pop();
    } else if (el !== '' && el !== '.') {
      // 경로가 '.'이거나 ''이 아닐 때, 배열에 추가한다.
      // 만약 '.'이면 그 뜻은 현재 디렉토리이기 때문에 추가하지 않는다.
      // 또한 ''이면 그 뜻은 "/"이기 때문에 추가하지 않는다.
      stack.push(el);
    }
  });

  // 경로를 '/'로 구분하여 문자열로 반환한다.
  return '/' + stack.join('/');
};

// 매개변수
// path : 유닉스 스타일 파일 시스템에서 파일 또는 디렉토리로 가는 절대 경로

// 출력
// 단순화된 규범적 경로

// 문제 설명 및 해결
// 유닉스 스타일 파일 시스템에서, 점 '.'은 현재 디렉토리를 나타내며, 두 개의 점 '..'은 상위 디렉토리를 나타낸다.
// 그리고 여러 개의 연속된 슬래시(예: '//')는 단일 슬래시 '/'로 처리된다.
// 이 문제에서는 '...'과 같은 다른 형식의 점은 파일/디렉토리 이름으로 처리된다.
// 규범적 경로는 다음과 같은 형식을 가져야 한다.
// 경로는 단일 슬래시 '/'로 시작한다.
// 두 개의 디렉토리는 단일 슬래시 '/'로 구분된다.
// 경로는 슬래시 '/'로 끝나지 않는다.
// 경로에는 루트 디렉토리에서 대상 파일 또는 디렉토리까지의 경로만 포함된다(즉, 점 '.' 또는 두 개의 점 '..'이 없다).
// 위 규칙에 따라서 최종적으로 단순화된 규범적 경로를 반환한다.
// 이 문제를 해결하기 위해서는 스택을 사용한다.
// 먼저 path를 "/" 기준으로 split하고 forEach를 사용하여 경로를 순회한다.
// 만약 경로가 ".."이면 배열의 마지막 요소를 제거한다.(상위요소로 이동한다는 의미이기 때문에 상위 요소의 경로가 의미가 없어진다.)
// 그리고 경로가 "."이거나 ""이 아니면 배열에 추가한다.
// 경로가 "."라는 의미는 현재 경로를 의미하기 때문에 의미가 없다.
// 경로가 ""라는 의미는 "/"이기 때문에 의미가 없다.
// 마지막으로 경로를 "/"로 구분하여 문자열로 반환한다.(제일 첫번째에 "/" 추가)

// 처음 문제를 해석할 때는 문제가 이해가 되지 않았지만, 터미널에 직접 명령어를 입력해보면서 문제를 이해할 수 있었다.
