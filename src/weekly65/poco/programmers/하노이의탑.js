// https://school.programmers.co.kr/learn/courses/30/lessons/12946

function solution(n) {
  const answer = [];

  // from : 시작 기둥
  // to : 목표 기둥
  // via : 경유 기둥
  const hanoi = (n, from, to, via) => {
    // 원판이 하나인 경우에는 시작 기둥에서 목표 기둥으로 이동하고 return
    if (n === 1) {
      answer.push([from, to]);
      return;
    }
    // 만약 원판이 2개 이상이면
    // 1번 기둥에 남은 N개 중 N-1개를 2번 기둥에 옮긴다. (3번 기둥을 보조 기둥으로 사용)
    // 1번 기둥에 남은 가장 큰 원판을 3번 기둥에 옮긴다.
    // 2번 기둥에 남은 N-1개의 원판들을 3번 기둥에 옮긴다. (1번 기둥을 보조 기둥으로 사용)

    hanoi(n - 1, from, via, to);
    answer.push([from, to]);
    hanoi(n - 1, via, to, from);
  };
  hanoi(n, 1, 3, 2);

  return answer;
}

// console.log(solution(2)); // [ [1, 2], [1, 3], [2, 3] ]
// console.log(solution(3)); // [ [1, 3], [1, 2], [3, 2], [1, 3], [2, 1], [2, 3], [1, 3] ]
console.log(solution(4)); // [ [ 1, 2 ], [ 1, 3 ],  [ 2, 3 ], [ 1, 2 ],  [ 3, 1 ], [ 3, 2 ],  [ 1, 2 ], [ 1, 3 ],  [ 2, 3 ], [ 2, 1 ],  [ 3, 1 ], [ 2, 3 ],  [ 1, 2 ], [ 1, 3 ],  [ 2, 3 ] ]

// 매개변수
// n : 원판의 개수

// 출력
// 하노이의 탑을 옮기는 순서를 담은 배열을 반환

// 문제 설명 및 해결
// 세 개의 기둥과 이 기둥에 꽃을 수 있는 크기가 다양한 원판들이 있고, 퍼즐이 시작하기 전에는 첫 번째 기둥에 원판들이 작은 것이 위에 있도록 순서대로 쌓여 있다.
// 다음의 두 가지 조건을 만족시키면서, 한 기둥에 꽂힌 원판들을 그 순서 그대로 다른 기둥으로 옮겨서 n개의 원판을 최소로 3번 원판에 쌓는 것이 목적이다.
// 1. 한 번에 하나의 원판만 옮길 수 있다.
// 2. 큰 원판이 작은 원판 위에 있어서는 안된다.
// 남은 원판이 1개면 목적지에 옮긴다. (종료 조건)
// 남은 원판이 N개 이면
// 1번 기둥에 남은 N개 중 N-1개를 2번 기둥에 옮긴다. (3번 기둥을 보조 기둥으로 사용)
// 1번 기둥에 남은 가장 큰 원판을 3번 기둥에 옮긴다.
// 2번 기둥에 남은 N-1개의 원판들을 3번 기둥에 옮긴다. (1번 기둥을 보조 기둥으로 사용)
